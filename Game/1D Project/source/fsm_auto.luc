module fsm_auto (
    input clk,  // clock
    input rst,  // reset

    input start_button,
    /*
    input reset_button,
    input p1_button1,
    input p1_button2,
    input p1_button3,
    input p1_button4,
    input p2_button1,
    input p2_button2,
    input p2_button3,
    input p2_button4,
    input regfile_datain[16],

    */
    input dec,
    input rng16[16],

    output alufn[6],
    output asel[3],
    output bsel[3],
    output wdsel[2],
    output regfile_wa[4],
    output regfile_ra[4],
    output regfile_rb[4],
    output we_regfile,

    output main_timer_sel[4],
    output main_timer_segs[8],
    output mini_timer_segs[8],

    //Outputs for LEDs
    output p1_led1[16],
    output p1_led2[16],
    output p1_led3[16],
    output p1_led4[16],
    output p2_led1[16],
    output p2_led2[16],
    output p2_led3[16],
    output p2_led4[16]

  ) {

    .clk(clk){

    //edge_detector edge_detector_variableCounter (#RISE(1), #FALL(0));
    //edge_detector edge_detector_slow_timer(#RISE(1), #FALL(0));

    .rst(rst) {
      variable_counter vc;
      counter slow_timer(#SIZE(1),#DIV(26)); // higher div, slower the clock

      multi_seven_seg seg;
      multi_dec_ctr dec_ctr;
      decimal_counter_5 dctr (#INIT(d5));
      //pn_gen random;

      dff mini_timer[4](#INIT(0));
      dff p1_col1[16] (#INIT(0)); //Registers for LED columns
      dff p1_col2[16] (#INIT(0));
      dff p1_col3[16] (#INIT(0));
      dff p1_col4[16] (#INIT(0));
      dff p2_col1[16] (#INIT(0));
      dff p2_col2[16] (#INIT(0));
      dff p2_col3[16] (#INIT(0));
      dff p2_col4[16] (#INIT(0));
    }

    fsm states = {
      IDLE_1,
      START,
      START_COUNTDOWN,
      SET_MAIN_TIMER_60,
      DECREASE_GAMETIMER,
      MINITIMER_SET_5,
      MINITIMER_SET_2,
      DECREASE_MINITIMER,
      INCREMENT_P1_SCORE,
      INCREMENT_P2_SCORE,
      GEN_LED_SEQUENCE,
      IDLE_2,
      SHR_P1_B1,
      SHR_P1_B2,
      SHR_P1_B3,
      SHR_P1_B4,
      SHR_P2_B1,
      SHR_P2_B2,
      SHR_P2_B3,
      SHR_P2_B4,
      SET_P1_B1_0,
      SET_P1_B2_0,
      SET_P1_B3_0,
      SET_P1_B4_0,
      SET_P2_B1_0,
      SET_P2_B2_0,
      SET_P2_B3_0,
      SET_P2_B4_0,
      CHECK_WIN_P1,
      LOSE_P1,
      CHECK_WIN_P2,
      LOSE_P2}; // main fsm to get user inputs and display results
  }

  seven_seg oneseg; //for the mini-timer

  look_up_table lookup1;
  look_up_table lookup2;
  look_up_table lookup3;
  look_up_table lookup4;


  always {

    alufn = 0;
    asel = 0;
    bsel = 0;
    wdsel = 0;
    regfile_wa = 1111;
    regfile_ra = 0000;
    regfile_rb = 0000;
    we_regfile = 0;

    dec_ctr.dec = dec; //dec is from au_top, to decrease the timer.
    oneseg.char = 4b0;

    seg.values[1] = 4b0;
    seg.values[0] = 4b0;
    main_timer_sel = seg.sel;  //4 bit
    main_timer_segs = ~seg.seg; //8 bit
    mini_timer_segs = seg.seg; //8 bit

    dctr.dec = 0;

    //These are the default input values for the lookup tables! We set 0 to be the defualt

    lookup1.randgen = 0;
    lookup2.randgen = 0;
    lookup3.randgen = 0;
    lookup4.randgen = 0;


    //These are the default values for the LEDs! The default is that all LEDs light up.
    p1_led1 = p1_col1.q;
    p1_led2 = p1_col2.q;
    p1_led3 = p1_col3.q;
    p1_led4 = p1_col4.q;

    p2_led1 = p2_col1.q;
    p2_led2 = p2_col2.q;
    p2_led3 = p2_col3.q;
    p2_led4 = p2_col4.q;


    mini_timer.d = dctr.value;
    oneseg.char = mini_timer.q;
    mini_timer_segs = oneseg.segs;


    case(states.q){

      states.IDLE_1:

        if(start_button){
          states.d = states.START;
        }

      //Set main timer to 60 seconds
      states.START:
      //if start button is pressed (Start_button == 1)

        mini_timer.d = dctr.value;
        oneseg.char = mini_timer.q;
        mini_timer_segs = oneseg.segs;
        dctr.dec = dec;

        //OLD
        //oneseg.char = dec_ctr.onedigit;



        if(mini_timer.q == 0){

          //FOR MAIN TIMER
          seg.values = dec_ctr.digits;
          main_timer_segs = ~seg.seg; // connect segments to the driver
          main_timer_sel = seg.sel; // connect digit select to the driver
          states.d = states.GEN_LED_SEQUENCE;
        }

      /*OLD CODE
        if(oneseg.segs == 0){
          seg.values = dec_ctr.digits;
          main_timer_segs = ~seg.seg; // connect segments to the driver
          main_timer_sel = seg.sel; // connect digit select to the driver
          //states.d = states.GEN_LED_SEQUENCE;
        }
      */



      //Generate the random LED sequence for both players

       states.GEN_LED_SEQUENCE:

        //led_register.d = rng16; //Store the LED sequence. Probably not needed?

        //Generate the LED sequence by getting 4 bits for each column from the randomly generated 16 bit number.
        lookup1.randgen = rng16[3:0];
        lookup2.randgen = rng16[7:4];
        lookup3.randgen = rng16[11:8];
        lookup4.randgen = rng16[15:12];

        //Store the generated sequence into the column registers for each player
        p1_col1.d[3:0] = lookup1.led_Out; //Not sure if need to declare where to put the bits because we want it to be the first 4. Remove if not needed.
        p1_col2.d = lookup2.led_Out;
        p1_col3.d = lookup3.led_Out;
        p1_col4.d = lookup4.led_Out;

        p2_col1.d = lookup1.led_Out;
        p2_col2.d = lookup2.led_Out;
        p2_col3.d = lookup3.led_Out;
        p2_col4.d = lookup4.led_Out;

        //Output to au_top which will then display the LEDs using io_led
        p1_led1 = p1_col1.q;
        p1_led2 = p1_col2.q;
        p1_led3 = p1_col3.q;
        p1_led4 = p1_col4.q;

        p2_led1 = p2_col1.q;
        p2_led2 = p2_col2.q;
        p2_led3 = p2_col3.q;
        p2_led4 = p2_col4.q;
        //states.d = states.START;





    }

  }
}
