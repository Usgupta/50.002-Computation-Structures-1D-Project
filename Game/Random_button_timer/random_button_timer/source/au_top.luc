module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_sel[4],
    output io_seg[8],
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    
    
    //edge_detector edge_detector_variableCounter (#RISE(1), #FALL(0));
    edge_detector edge_detector_slow_timer(#RISE(1), #FALL(0));
    
    
    
    //button conditioner
    button_conditioner btn_cond1;
    button_conditioner btn_cond2;
    button_conditioner btn_cond3;
    button_conditioner btn_cond4;
    
    
    //edge detector
    edge_detector edge_btn1(#RISE(1), #FALL(0));
    edge_detector edge_btn2(#RISE(1), #FALL(0));
    edge_detector edge_btn3(#RISE(1), #FALL(0));
    edge_detector edge_btn4(#RISE(1), #FALL(0));
    
    
    .rst(rst) { 
      variable_counter vc;  
      counter slow_timer(#SIZE(1),#DIV(26)); // higher div, slower the clock
      //dff led_register[16](#INIT(0));  
      dff col1_register[4](#INIT(0));
      dff col2_register[4](#INIT(0)); 
      dff col3_register[4](#INIT(0));
      dff col4_register[4](#INIT(0)); 
      dff mini_timer[3](#INIT(0));
      dff main_timer[4](#INIT(0));
      
      
      multi_seven_seg seg; 
      multi_dec_ctr dec_ctr; 
      pn_gen random;
      
      

    } 
  }
  
  
  alu16 alu;
  
  look_up_table lookup1;  // column1 
  look_up_table lookup2;  // column2
  look_up_table lookup3;  // column3
  look_up_table lookup4;  // column4
  
  always {
  
    
    ///// initial value
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off

    usb_tx = usb_rx;        // echo the serial data
    io_sel = 0;
    io_seg = 0;
    io_led = 3x{{8h00}};
    
    alu.a = 0;
    alu.b = 0;
    alu.alufn = 0;
    
    /////
    
    
    // same seed when reset
    random.seed = 128h843233523a613966423b622562592c62;
    edge_detector_slow_timer.in = slow_timer.value;
    random.next = edge_detector_slow_timer.out;
    
    
    dec_ctr.dec = edge_detector_slow_timer.out; 
        
    
    lookup1.randgen = random.num[3:0];
    lookup2.randgen = random.num[7:4];
    lookup3.randgen = random.num[11:8];
    lookup4.randgen = random.num[15:12];
    
    
    //pass hardcoded value for led to register
    //col1_register.d = lookup1.led_Out[3:0];
    //col2_register.d = lookup2.led_Out[3:0];
    //col3_register.d = lookup3.led_Out[3:0];
    //col4_register.d = lookup4.led_Out[3:0];
    
    
    if(mini_timer.q == b0){
      col1_register.d = lookup1.led_Out[3:0];
      col2_register.d = lookup2.led_Out[3:0];
      col3_register.d = lookup3.led_Out[3:0];
      col4_register.d = lookup4.led_Out[3:0];
      mini_timer.d = b101;
    }
    
    if(slow_timer.value == 1){
      mini_timer.d = mini_timer.q - b1;
    }
    
   // seg.values = {8he, 8hf, 8hf, 8h14};
    
    
    //btn 1
    //pin io_led[1][6] A24;
    //pin io_led[1][7] A23;
    //pin io_led[2][0] A21;
    //pin io_led[2][1] A20;
    io_led[1][6] = col1_register.q[0]; //A24 pin 3
    
    io_led[1][7] = col1_register.q[1]; //A23 pin 18 
    
    io_led[2][0] = col1_register.q[2]; //A21 pin 6 
    
    io_led[2][1] = col1_register.q[3]; //A20 pin 7
    
    
      
    // btn 2
    //pin io_led[0][0] B21;
    //pin io_led[0][1] B20;
    //pin io_led[0][2] B18;
    //pin io_led[0][3] B17;    
    io_led[0][0] = col2_register.q[0]; //B21 
    
    io_led[0][1] = col2_register.q[1]; //B20 
    
    io_led[0][2] = col2_register.q[2]; //B18 
    
    io_led[0][3] = col2_register.q[3]; //B17 
    
    
    
    
    
    //pin io_led[1][0] B9;
    //pin io_led[1][1] B8;
    //pin io_led[1][2] B6;
    //pin io_led[1][3] B5;
    io_led[1][0] = col3_register.q[0]; //B9 
    
    io_led[1][1] = col3_register.q[1]; //B8
    
    io_led[1][2] = col3_register.q[2]; //B6 
    
    io_led[1][3] = col3_register.q[3]; //B5 
    
    
    
    
    
    //pin io_led[2][4] A15;
    //pin io_led[2][5] A14;
    //pin io_led[2][6] A12;
    //pin io_led[2][7] A11;
    io_led[2][4] = col4_register.q[0]; //A15 
    
    io_led[2][5] = col4_register.q[1]; //A14
    
    io_led[2][6] = col4_register.q[2]; //A12
    
    io_led[2][7] = col4_register.q[3]; //A11
    
    
    
    //pin io_dip[0][6] B39 pulldown;    
    //pin io_dip[0][4] B36 pulldown;
    //pin io_dip[0][7] B40 pulldown;
    //pin io_dip[1][0] B42 pulldown;
    
    btn_cond1.in = io_dip[0][6];
    
    btn_cond2.in = io_dip[0][4];
    
    btn_cond3.in = io_dip[0][7];
    
    btn_cond4.in = io_dip[1][0];
    
    
    
    edge_btn1.in = btn_cond1.out;
    
    edge_btn2.in = btn_cond2.out;
    
    edge_btn3.in = btn_cond3.out;
    
    edge_btn4.in = btn_cond4.out;
    
    
    //for indicate and debugging
    io_led[0][4] = edge_btn1.out;
    io_led[0][5] = edge_btn2.out;
    io_led[0][6] = edge_btn3.out;
    io_led[0][7] = edge_btn4.out;
    
    
    
    if(edge_btn1.out == 1){
      alu.a = col1_register.q;
      alu.b = b1;
      alu.alufn = b100001; // shift right by 1 bit
      col1_register.d = alu.out[3:0];
      
    }
    
    if(edge_btn2.out == 1){
      alu.a = col2_register.q;
      alu.b = b1;
      alu.alufn = b100001;  // shift right by 1 bit
      col2_register.d = alu.out[3:0];
    }
    
    if(edge_btn3.out == 1){
      alu.a = col3_register.q;
      alu.b = b1;
      alu.alufn = b100001; // shift right by 1 bit
      col3_register.d = alu.out[3:0];
      
    }
    
    if(edge_btn4.out == 1){
      alu.a = col4_register.q;
      alu.b = b1;
      alu.alufn = b100001;  // shift right by 1 bit
      col4_register.d = alu.out[3:0];
    }
    
    //pin io_seg[0] A5;  segment 0
    //pin io_seg[1] A6;  segment 1
    //pin io_seg[2] A48; segment 2
    //pin io_seg[3] A46; segment 3
    //pin io_seg[4] A45; segment 4
    //pin io_seg[5] A3; segment 5
    //pin io_seg[6] A2; segment 6
    
    // pin io_sel[2] A42;  gnd digit 0
    // pin io_sel[3] A43;  gnd digit 1
    
    seg.values = dec_ctr.digits;
    
    io_seg = ~seg.seg; // connect segments to the driver
    io_sel = ~seg.sel; // connect digit select to the driver
    
    
   
    
  }
}