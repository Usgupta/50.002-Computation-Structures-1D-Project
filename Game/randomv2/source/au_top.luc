module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    
    input usb_rx,           // USB->Serial input
    output usb_tx,           // USB->Serial output
    output io_led[3][8],    // led output
    output io_seg [8],      // 7-segment LEDs on IO Shield 
    output io_sel [4],      // Digit select on IO Shield 
    input io_button [5],    // 5 buttons on IO Shield 
    input io_dip [3][8]     // DIP switches on IO Shield
    

  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    
    
    edge_detector edge_detector_variableCounter (#RISE(1), #FALL(0));
    
    .rst(rst) { 
      variable_counter vc;  
      //counter slow_timer(#SIZE(1),#DIV(26)); 
      dff led_register[16];  
      

    } 
  }
  
  
  
  look_up_table lookup;  // look_up_table 
  
  always {
  
    
    led = 8h00;             // turn LEDs off
  
    io_led = 3x{{8h00}};    // turn LEDs off 
    io_seg = 8hff;          // turn segments off 
    io_sel = 4hf;   
    
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    
    rst = reset_cond.out;   // conditioned reset
    

    usb_tx = usb_rx;        // echo the serial data
    
    edge_detector_variableCounter.in = vc.out;
    
    led_register.d = edge_detector_variableCounter.out;
    
    lookup.randgen = led_register.q[3:0];
    
    io_led[0][3:0] = lookup.led_Out;
    
  }
}