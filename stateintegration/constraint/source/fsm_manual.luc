/*
module fsm_manual (
    input clk,  // clock
    input rst,  // reset
    
    input start_button,
    input reset_button,
    input p1_button1,
    input p1_button2, 
    input p1_button3,
    input p1_button4, 
    input p2_button1,
    input p2_button2, 
    input p2_button3,
    input p2_button4, 
    
    output alufn[6],
    output asel[3],
    output 
    
    output out,
    output io_led [3][8],   // LEDs on IO Shield
    output main_timer_sel[4],
    output main_timer_segs[8],
    output mini_timer_segs[8],
    output p1_led[16],
    output p2_led[16],
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
    
  ) {

  .clk(clk){
    
    //edge_detector edge_detector_variableCounter (#RISE(1), #FALL(0));
    edge_detector edge_detector_slow_timer(#RISE(1), #FALL(0));
    
    .rst(rst) {
      variable_counter vc;  
      counter slow_timer(#SIZE(1),#DIV(26)); // higher div, slower the clock
      dff led_register[16](#INIT(0));  
      dff p1_col1_register[4](#INIT(0));
      dff p1_col2_register[4](#INIT(0)); 
      dff p1_col3_register[4](#INIT(0));
      dff p1_col4_register[4](#INIT(0)); 
      dff p2_col1_register[4](#INIT(0));
      dff p2_col2_register[4](#INIT(0)); 
      dff p2_col3_register[4](#INIT(0));
      dff p2_col4_register[4](#INIT(0)); 
      dff mini_timer[3](#INIT(0));
      dff main_timer[4](#INIT(0));
      
      multi_seven_seg seg; 
      multi_dec_ctr dec_ctr; 
      pn_gen random;
    }
    
    fsm states = {      
      START,
      START_COUNTDOWN,
      SET_MAIN_TIMER_60,
      DECREASE_GAMETIMER,
      MINITIMER_SET_5,
      MINITIMER_SET_2,
      DECREASE_MINITIMER,
      INCREMENT_P1_SCORE,
      INCREMENT_P2_SCORE,
      GEN_LED_SEQUENCE,
      IDLE_2,
      SHR_P1_B1,
      SHR_P1_B2,
      SHR_P1_B3,
      SHR_P1_B4,
      SHR_P2_B1,
      SHR_P2_B2,
      SHR_P2_B3,
      SHR_P2_B4,
      SET_P1_B1_0,
      SET_P1_B2_0,
      SET_P1_B3_0,
      SET_P1_B4_0,
      SET_P2_B1_0,
      SET_P2_B2_0,
      SET_P2_B3_0,
      SET_P2_B4_0,
      CHECK_WIN_P1,
      LOSE_P1,
      CHECK_WIN_P2,
      LOSE_P2}; // main fsm to get user inputs and display results
  }
  
  
  
  alu16 alu;
  
  look_up_table lookup1;  // column1 
  look_up_table lookup2;  // column2
  look_up_table lookup3;  // column3
  look_up_table lookup4;  // column4
  
  seven_seg oneseg; //for the mini-timer
  
  always {
    
    // same seed when reset
    random.seed = 128h843233523a613966423b622562592c62;
    edge_detector_slow_timer.in = slow_timer.value;
    random.next = edge_detector_slow_timer.out;
    
    
    dec_ctr.dec = edge_detector_slow_timer.out; 
        
    
    lookup1.randgen = random.num[3:0];
    lookup2.randgen = random.num[7:4];
    lookup3.randgen = random.num[11:8];
    lookup4.randgen = random.num[15:12];
    
    
    //pass hardcoded value for led to register
    //col1_register.d = lookup1.led_Out[3:0];
    //col2_register.d = lookup2.led_Out[3:0];
    //col3_register.d = lookup3.led_Out[3:0];
    //col4_register.d = lookup4.led_Out[3:0];
    
    
    if(mini_timer.q == b0){
      col1_register.d = lookup1.led_Out[3:0];
      col2_register.d = lookup2.led_Out[3:0];
      col3_register.d = lookup3.led_Out[3:0];
      col4_register.d = lookup4.led_Out[3:0];
      mini_timer.d = b101;
    }
    
    if(slow_timer.value == 1){
      mini_timer.d = mini_timer.q - b1;
    }
 
    
    //pin io_dip[0][6] B39 pulldown;    
    //pin io_dip[0][4] B36 pulldown;
    //pin io_dip[0][7] B40 pulldown;
    //pin io_dip[1][0] B42 pulldown;
    
    btn_cond1.in = io_dip[0][6];
    
    btn_cond2.in = io_dip[0][4];
    
    btn_cond3.in = io_dip[0][7];
    
    btn_cond4.in = io_dip[1][0];
    
    
    
    edge_btn1.in = btn_cond1.out;
    
    edge_btn2.in = btn_cond2.out;
    
    edge_btn3.in = btn_cond3.out;
    
    edge_btn4.in = btn_cond4.out;
    
    
    //for indicate and debugging
    io_led[0][4] = edge_btn1.out;
    io_led[0][5] = edge_btn2.out;
    io_led[0][6] = edge_btn3.out;
    io_led[0][7] = edge_btn4.out;
    
    
    case(states.q){
    
      //Set main timer to 60 seconds
      states.START:
      //if start button is pressed (Start_button == 1) 
        oneseg.char = dec_ctr.onedigit;
        mini_timer_segs = oneseg.segs;
        if(oneseg.segs == 0){
          seg.values = dec_ctr.digits;
          main_timer_segs = ~seg.seg; // connect segments to the driver
          main_timer_sel = seg.sel; // connect digit select to the driver
          states.d = states.GEN_LED_SEQUENCE;
        }
        
      states.GEN_LED_SEQUENCE:
      
        led_register.d = random.num[15:0]; // generate LED sequence
        
        lookup1.randgen = random.num[3:0];
        lookup2.randgen = random.num[7:4];
        lookup3.randgen = random.num[11:8];
        lookup4.randgen = random.num[15:12];
        
        p1_col1_register.d = lookup1.led_Out;
        p1_col2_register.d = lookup2.led_Out;
        p1_col3_register.d = lookup3.led_Out;
        p1_col4_register.d = lookup4.led_Out;
      
        p2_col1_register.d = lookup1.led_Out;
        p2_col2_register.d = lookup2.led_Out;
        p2_col3_register.d = lookup3.led_Out;
        p2_col4_register.d = lookup4.led_Out;
        
        
      states.MINITIMER_SET_5:
      
        //reset mini_timer to 5 seconds
        //Next state = IDLE
        
        
      states.IDLE_2:
      
        //This state does nothing, wait for button input and branch to next states
        if(p1_edge_btn1.out == 1){
          states.d = states.SHR_P1_B1;
        }
        
        if(p1_edge_btn2.out == 1){
          states.d = states.SHR_P1_B2; 
        }
        
        if(p1_edge_btn3.out == 1){
          states.d = states.SHR_P1_B3;
        }
        
        if(p1_edge_btn4.out == 1){
          states.d = states.SHR_P1_B4;  
        }
        
        if(p2_edge_btn1.out == 1){
          states.d = states.SHR_P2_B1;
        }
        
        if(p2_edge_btn2.out == 1){
          states.d = states.SHR_P2_B2; 
        }
        
        if(p2_edge_btn3.out == 1){
          states.d = states.SHR_P2_B3;
        }
        
        if(p2_edge_btn4.out == 1){
          states.d = states.SHR_P2_B4;  
        }
          
      states.SHR_P1_B1:
        
        if(p1_col1_register.q != 0){
          alu.a = p1_col1_register.q;
          alu.b = b1;
          alu.alufn = b100001; // shift right by 1 bit
          p1_col1_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P1;  
        }
        
        states.d = states.LOSE_P1;

        
      states.SHR_P1_B2:
      
        if(p1_col2_register.q != 0){
          alu.a = p1_col2_register.q;
          alu.b = b1;
          alu.alufn = b100001;  // shift right by 1 bit
          p1_col2_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P1;
        }
        
        states.d = states.LOSE_P1;
       
      states.SHR_P1_B3:
       
        if(p1_col3_register.q != 0){
          alu.a = p1_col3_register.q;
          alu.b = b1;
          alu.alufn = b100001; // shift right by 1 bit
          p1_col3_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P1;
        }
        
        states.d = states.LOSE_P1;
      
      states.SHR_P1_B4:
        
        if(p1_col4_register.q != 0){
          alu.a = p1_col4_register.q;
          alu.b = b1;
          alu.alufn = b100001;  // shift right by 1 bit
          p1_col4_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P1;
        }
        
        states.d = states.LOSE_P1; 
      
      states.SHR_P2_B1:
      
        if(p2_col1_register.q != 0){
          alu.a = p2_col1_register.q;
          alu.b = b1;
          alu.alufn = b100001; // shift right by 1 bit
          p2_col1_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P2;
        }
        
        states.d = states.LOSE_P2;
        
      states.SHR_P2_B2:
      
        if(p2_col2_register.q != 0){
          alu.a = p2_col2_register.q;
          alu.b = b1;
          alu.alufn = b100001; // shift right by 1 bit
          p2_col2_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P2;
        }
        
        states.d = states.LOSE_P2;
        
      states.SHR_P2_B3:
      
        if(p2_col3_register.q != 0){
          alu.a = p2_col3_register.q;
          alu.b = b1;
          alu.alufn = b100001; // shift right by 1 bit
          p2_col3_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P2;
        }
        
        states.d = states.LOSE_P2;
        
      states.SHR_P2_B4:
      
        if(p2_col4_register.q != 0){
          alu.a = p2_col4_register.q;
          alu.b = b1;
          alu.alufn = b100001; // shift right by 1 bit
          p2_col4_register.d = alu.out[3:0];
          states.d = states.CHECK_WIN_P2;
        }
        
        states.d = states.LOSE_P2;
      
      states.CHECK_WIN_P1:
      
        if(p1_col1_register.q == 0 && p1_col2_register.q == 0 && p1_col3_register.q == 0 & p1_col4_register.q == 0){
          states.d = states.INCREMENT_P1_SCORE;
        }
        
        else{
          states.d = states.IDLE_2;
        }
        
      states.CHECK_WIN_P2:
      
        if(p2_col1_register.q == 0 && p2_col2_register.q == 0 && p2_col3_register.q == 0 & p2_col4_register.q == 0){
          states.d = states.INCREMENT_P1_SCORE;
        }
        
        else{
          states.d = states.IDLE_2;
        }
        
      states.LOSE_P1:
      
        //DISPLAY CROSS
        
      states.LOSE_P2:
      
        //DISPLAY CROSS
        
      states.INCREMENT_P1_SCORE:
      
        
        
      states.INCREMENT_P2_SCORE:
        
    }
    
  }
}
*/